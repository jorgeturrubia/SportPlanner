# Gu√≠a Integral de Arquitectura, Patrones, Antipatrones y Buenas Pr√°cticas Angular 20 + TypeScript 5.9.2

## Resumen Ejecutivo
Esta gu√≠a est√° orientada a agentes autom√°ticos y desarrolladores avanzados, cubriendo:
- Arquitectura limpia y escalable en Angular 20
- Patrones y antipatrones en Angular y TypeScript 5.9.2
- Control flow modernizado con bloques @if, @for, @switch (reemplazando directivas deprecadas)
- **Tailwind CSS v4** como framework de estilos oficial del proyecto
- **Componentizaci√≥n exhaustiva** para m√°xima reutilizaci√≥n
- **Separaci√≥n obligatoria** de archivos `.ts`, `.html`, `.scss`
- **Modo Light y Dark** implementado en todos los componentes
- Mejores pr√°cticas para estructuraci√≥n de componentes en archivos separados
- Checklist para revisi√≥n autom√°tica y codificaci√≥n asistida

---

## üö® CR√çTICO: MCP Server de Angular - Recurso Principal

**‚ö†Ô∏è IMPORTANTE: Este proyecto tiene acceso a un MCP (Model Context Protocol) Server de Angular que proporciona:**

- ‚úÖ **Best Practices Guide oficial** de Angular actualizado constantemente
- ‚úÖ **B√∫squeda en documentaci√≥n oficial** de Angular (https://angular.dev)
- ‚úÖ **APIs, tutoriales, conceptos y ejemplos** directamente desde la fuente oficial
- ‚úÖ **Informaci√≥n actualizada** sobre standalone components, signals, control flow, y todas las caracter√≠sticas modernas

### üìò Herramientas MCP Disponibles

1. **`mcp_angular-cli_get_best_practices`**
   - Recupera la **Angular Best Practices Guide** completa
   - Contiene reglas y convenciones **imprescindibles** para desarrollo Angular moderno
   - **OBLIGATORIO consultarla** antes de escribir o modificar c√≥digo Angular

2. **`mcp_angular-cli_search_documentation`**
   - Busca en la documentaci√≥n oficial de Angular (angular.dev)
   - Devuelve contenido actualizado de la p√°gina con snippets relevantes
   - √ösala para resolver dudas sobre APIs espec√≠ficas, sintaxis, o patrones

### üéØ Workflow Obligatorio para Agentes

**ANTES de crear/modificar c√≥digo Angular:**

1. **Consultar MCP Server primero:**
   ```
   - Usar mcp_angular-cli_get_best_practices para obtener gu√≠a completa
   - Usar mcp_angular-cli_search_documentation para APIs/conceptos espec√≠ficos
   ```

2. **Revisar esta gu√≠a (AGENTS.md)** para:
   - Estructura de carpetas y convenciones del proyecto SportPlanner
   - Patrones espec√≠ficos ya establecidos en el proyecto
   - Antipatrones a evitar

3. **Consultar documentaci√≥n de negocio** en `DocSportPlanner/`:
   - Reglas de dominio deportivo
   - Requisitos funcionales
   - Modelos de datos

### üìå Ejemplos de Uso del MCP Server

**Para obtener best practices:**
```
Query: "Angular best practices guide"
Tool: mcp_angular-cli_get_best_practices
```

**Para buscar informaci√≥n espec√≠fica:**
```
Query: "standalone components"
Tool: mcp_angular-cli_search_documentation

Query: "signals computed effect"
Tool: mcp_angular-cli_search_documentation

Query: "NgModule vs standalone"
Tool: mcp_angular-cli_search_documentation
```

### ‚ö° Ventajas del MCP Server

- **Siempre actualizado:** Acceso directo a la documentaci√≥n oficial m√°s reciente
- **Evita informaci√≥n desactualizada:** Mejor que confiar en conocimiento est√°tico
- **Autoridad oficial:** Viene directamente de angular.dev
- **Ejemplos precisos:** C√≥digo verificado y mantenido por el equipo de Angular

### üî¥ Regla de Oro

> **NUNCA escribas c√≥digo Angular sin consultar primero el MCP Server.**
> 
> La informaci√≥n del MCP Server tiene **prioridad sobre cualquier otra fuente**, incluido el contenido de este archivo si hay contradicciones (aunque este archivo se mantiene alineado con las best practices oficiales).

---

## üé® CR√çTICO: Tailwind CSS v4 - Framework de Estilos Oficial

**‚ö†Ô∏è IMPORTANTE: Este proyecto usa Tailwind CSS v4 como framework de estilos √öNICO.**

### üìê Reglas de Estilos

1. **Tailwind CSS v4 OBLIGATORIO**
   - ‚úÖ Usar clases de Tailwind para TODOS los estilos
   - ‚ùå NO escribir CSS custom en archivos `.scss` salvo casos excepcionales
   - ‚úÖ Aprovechar las utility classes de Tailwind
   - ‚úÖ Usar `@apply` solo cuando sea necesario para componentes complejos

2. **Modo Light y Dark (OBLIGATORIO)**
   - ‚úÖ **TODOS los componentes** deben soportar `light` y `dark` mode
   - ‚úÖ Usar las clases `dark:` de Tailwind para modo oscuro
   - ‚úÖ Definir colores con variables CSS para temas
   - ‚úÖ Probar AMBOS modos antes de considerar completo un componente
   - ‚ùå NO hardcodear colores que no soporten dark mode

3. **Separaci√≥n de Archivos (OBLIGATORIO)**
   - ‚úÖ `.ts` ‚Üí L√≥gica del componente
   - ‚úÖ `.html` ‚Üí Template con clases de Tailwind
   - ‚úÖ `.scss` ‚Üí Solo para casos excepcionales o `@apply` custom
   - ‚ùå NUNCA inline templates o estilos en el `.ts`

4. **Componentizaci√≥n Exhaustiva**
   - ‚úÖ **Componetizar TODO** lo que sea reutilizable
   - ‚úÖ Crear componentes at√≥micos (botones, inputs, cards, badges, etc.)
   - ‚úÖ Componentes peque√±os y enfocados en una sola responsabilidad
   - ‚úÖ Reutilizar antes de duplicar c√≥digo
   - ‚úÖ Pensar en componentes como piezas de LEGO

### üé® Ejemplo de Componente con Tailwind v4 y Dark Mode

**button.component.ts**
```typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-button',
  standalone: true,
  templateUrl: './button.component.html',
  styleUrls: ['./button.component.scss']
})
export class ButtonComponent {
  @Input() variant: 'primary' | 'secondary' | 'danger' = 'primary';
  @Input() size: 'sm' | 'md' | 'lg' = 'md';
  @Input() disabled = false;
}
```

**button.component.html**
```html
<button
  [disabled]="disabled"
  [class]="[
    'rounded-lg font-semibold transition-colors duration-200',
    'focus:outline-none focus:ring-2 focus:ring-offset-2',
    'disabled:opacity-50 disabled:cursor-not-allowed',
    
    // Size variants
    size === 'sm' ? 'px-3 py-1.5 text-sm' : '',
    size === 'md' ? 'px-4 py-2 text-base' : '',
    size === 'lg' ? 'px-6 py-3 text-lg' : '',
    
    // Color variants (light + dark mode)
    variant === 'primary' ? [
      'bg-blue-600 text-white hover:bg-blue-700',
      'dark:bg-blue-500 dark:hover:bg-blue-600',
      'focus:ring-blue-500'
    ] : '',
    
    variant === 'secondary' ? [
      'bg-gray-200 text-gray-900 hover:bg-gray-300',
      'dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600',
      'focus:ring-gray-500'
    ] : '',
    
    variant === 'danger' ? [
      'bg-red-600 text-white hover:bg-red-700',
      'dark:bg-red-500 dark:hover:bg-red-600',
      'focus:ring-red-500'
    ] : ''
  ].flat().filter(Boolean).join(' ')"
>
  <ng-content></ng-content>
</button>
```

**button.component.scss**
```scss
// Solo para casos excepcionales - preferir Tailwind classes
// Este archivo puede estar vac√≠o o contener solo @apply
```

### üåì Configuraci√≥n de Dark Mode en Tailwind

**tailwind.config.js**
```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{html,ts}",
  ],
  darkMode: 'class', // Habilita dark mode con clase 'dark'
  theme: {
    extend: {
      colors: {
        // Colores personalizados que soporten light/dark
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          // ... m√°s tonos
          900: '#1e3a8a',
        },
      },
    },
  },
  plugins: [],
}
```

### üéØ Checklist de Estilos

- [ ] Usar clases de Tailwind CSS v4 para todos los estilos
- [ ] Implementar variantes `dark:` para TODOS los elementos visuales
- [ ] Probar componente en modo light Y dark antes de commit
- [ ] Componentizar elementos reutilizables (botones, cards, inputs, etc.)
- [ ] Separar `.ts`, `.html`, `.scss` en archivos distintos
- [ ] NO usar CSS inline en templates
- [ ] NO hardcodear colores sin considerar dark mode
- [ ] Documentar componentes reutilizables con ejemplos

---

> üìÅ **Nota - Documentaci√≥n del proyecto**
>
> El repositorio incluye una carpeta central con las especificaciones del proyecto, modelos y decisiones de dise√±o: `C:\Proyectos\SportPlanner\DocSportPlanner`.
>
> - Revisa `DocSportPlanner/` (por ejemplo `DocSportPlanner/docs/`, `DocSportPlanner/docs/tecnico/`, `DocSportPlanner/docs/tecnico/openapi.yaml`) antes de iniciar tareas de dise√±o o de backend/frontend.
> - Las `instructions` y `agents` para `front` y `back` deben consultar estos documentos para alinear requisitos, contratos de API y convenciones.


## 1. CR√çTICO: Control Flow Blocks - Cambio Fundamental en Angular 20

### Directivas Deprecadas en Angular 20
A partir de **Angular 20**, las siguientes directivas estructurales est√°n **DEPRECADAS** e ir√°n a remover en **v22**:
- `*ngIf` ‚Üí Usar `@if` block
- `*ngFor` ‚Üí Usar `@for` block
- `[ngSwitch]`, `*ngSwitchCase`, `*ngSwitchDefault` ‚Üí Usar `@switch` block

**Acci√≥n recomendada**: Ejecutar autom√°ticamente el schematic de migraci√≥n:
```bash
ng update @angular/core --name=control-flow-migration
```

### Nueva Sintaxis: Bloques de Control de Flujo

#### @if / @else if / @else
```typescript
// ‚úÖ CORRECTO - Angular 20
@if (condition) {
  <p>Condition is true</p>
} @else if (otherCondition) {
  <p>Other condition is true</p>
} @else {
  <p>No conditions met</p>
}

// ‚ùå DEPRECATED - Evitar
<div *ngIf="condition">
  <p>Condition is true</p>
</div>
<div *ngIf="otherCondition">
  <p>Other condition is true</p>
</div>
<div *ngIf="!condition && !otherCondition">
  <p>No conditions met</p>
</div>
```

#### @for (reemplaza *ngFor)
```typescript
// ‚úÖ CORRECTO - Angular 20
@for (item of items; track item.id) {
  <div>{{ item.name }}</div>
}

// Con @empty para lista vac√≠a
@for (item of items; track item.id) {
  <li>{{ item.name }}</li>
} @empty {
  <li>No items available</li>
}

// Variables locales: $index, $count, $first, $last, $even, $odd
@for (item of items; track item.id; let idx = $index, isEven = $even) {
  <div [class.even]="isEven">{{ idx }}: {{ item.name }}</div>
}

// ‚ùå DEPRECATED - Evitar
<div *ngFor="let item of items; trackBy: trackByFn">
  {{ item.name }}
</div>
```

**Ventaja clave**: El `track` es **obligatorio** en `@for` (evita memory leaks), mejora performance 90% respecto a `*ngFor`.

#### @switch / @case / @default
```typescript
// ‚úÖ CORRECTO - Angular 20
@switch (userRole) {
  @case ('admin') {
    <app-admin-dashboard />
  }
  @case ('editor') {
    <app-editor-dashboard />
  }
  @default {
    <app-viewer-dashboard />
  }
}

// ‚ùå DEPRECATED - Evitar
<div [ngSwitch]="userRole">
  <div *ngSwitchCase="'admin'">
    <app-admin-dashboard />
  </div>
  <div *ngSwitchCase="'editor'">
    <app-editor-dashboard />
  </div>
  <div *ngSwitchDefault>
    <app-viewer-dashboard />
  </div>
</div>
```

**Nota importante**: No hay "fall-through" en `@switch`, no necesita `break`.

### Migraci√≥n y Consideraciones
- **Control flow schematics**: Migra autom√°ticamente `*ngIf`, `*ngFor`, `*ngSwitch`
- **NgIf con async pipe**: La nueva sintaxis tambi√©n aplica bien con async:
  ```typescript
  @if (country$ | async; as countryList) {
    <span>Found {{ countryList.length }} countries</span>
  }
  ```
- **No requiere imports**: Los bloques `@if`, `@for`, `@switch` est√°n "built-in" en Angular 20+
- **Mejor legibilidad y type checking**: Los bloques soportan type narrowing en switch

---

## 2. Arquitectura Moderna Angular 20

### Separaci√≥n de Archivos (OBLIGATORIO)
- Cada componente **SIEMPRE** debe tener su `.ts`, `.html` y `.scss` en archivos **separados** y nombrados igual, agrupados en el mismo directorio.
- ‚ùå **PROHIBIDO** juntar plantilla HTML o estilos en el archivo `.ts` del componente
- ‚ùå **PROHIBIDO** usar `template: ''` o `styles: []` inline en el decorador `@Component`
- ‚úÖ **OBLIGATORIO** tener 3 archivos m√≠nimo: `.ts`, `.html`, `.scss` (aunque `.scss` est√© vac√≠o)
- Estructura ejemplo para `user-profile`:
  ```
  src/features/user/profile/
  ‚îú‚îÄ‚îÄ user-profile.component.ts      # L√≥gica
  ‚îú‚îÄ‚îÄ user-profile.component.html    # Template con Tailwind
  ‚îú‚îÄ‚îÄ user-profile.component.scss    # Vac√≠o o @apply custom
  ‚îú‚îÄ‚îÄ user-profile.component.spec.ts # Tests
  ```

### Organizaci√≥n de Carpetas
- Organizar por dominio/feature, no por tipo t√©cnico (evitar `components/`, `services/` gen√©ricos)
- Aplicar Domain-Driven Design (DDD) donde sea relevante
- **Componentizaci√≥n exhaustiva:** Crear carpeta `shared/components/` para componentes at√≥micos reutilizables
- Estructura recomendada:
  ```
  src/
  ‚îú‚îÄ‚îÄ shared/
  ‚îÇ   ‚îú‚îÄ‚îÄ components/        # Componentes reutilizables (botones, cards, inputs)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ badge/
  ‚îÇ   ‚îú‚îÄ‚îÄ services/          # Servicios compartidos
  ‚îÇ   ‚îî‚îÄ‚îÄ models/            # Modelos/interfaces compartidos
  ‚îú‚îÄ‚îÄ features/
  ‚îÇ   ‚îú‚îÄ‚îÄ users/             # Feature de usuarios
  ‚îÇ   ‚îú‚îÄ‚îÄ teams/             # Feature de equipos
  ‚îÇ   ‚îî‚îÄ‚îÄ training/          # Feature de entrenamientos
  ‚îî‚îÄ‚îÄ core/                  # Servicios singleton, guards, interceptors
  ```
- Colocar archivos de test (`*.spec.ts`) junto al c√≥digo bajo prueba
- Usar lazy loading y feature modules por dominio

### Standalone Components
- Preferir componentes `standalone: true` usando la API moderna.
- Minimizar NgModules y evitar m√≥dulos redundantes.
- Eliminar CommonModule imports innecesarias en componentes standalone (bloques @if/@for no requieren imports).

### Naming y Conceptos
- Prefiere nombres cortos, claros, √∫nicos y con significado de dominio.
- Usar un concepto por archivo/feature.
- Evitar nombres gen√©ricos: `utils.ts`, `common.ts`, `constants.ts` sin contexto.

---

## 3. Patrones Recomendados Angular 20

### Arquitectura y Componentes
- **Componentizaci√≥n exhaustiva:** Crear componentes peque√±os y reutilizables para TODO
- **Componentes at√≥micos:** Botones, inputs, cards, badges, etc. en `shared/components/`
- **Composici√≥n sobre duplicaci√≥n:** Reutilizar componentes antes de crear nuevos
- **Separaci√≥n obligatoria:** `.ts`, `.html`, `.scss` siempre en archivos separados

### Estilos y UI
- **Tailwind CSS v4 √öNICAMENTE:** No escribir CSS custom salvo excepciones
- **Dark mode obligatorio:** Todos los componentes deben soportar `light` y `dark`
- **Utility-first approach:** Usar clases de Tailwind directamente en templates
- **Responsive design:** Mobile-first con breakpoints de Tailwind (`sm:`, `md:`, `lg:`, etc.)

### Estado y Datos
- **Uso de signals** para estado local y derived state (preferir `signal()` sobre `BehaviorSubject` para UI local)
- **ChangeDetectionStrategy.OnPush** por defecto en todos los componentes
- **Servicios con una √∫nica responsabilidad**, singleton v√≠a `providedIn: 'root'`
- **Async pipe** en lugar de subscribes manuales en templates

### Control Flow y Performance
- **Bloques de control flow (@if, @for, @switch)** en lugar de directivas deprecadas
- **Lazy loading de rutas y features** para agilizar arranque inicial
- **Type narrowing** en @switch para aprovechamiento de tipos discriminated unions

### Testing y Documentaci√≥n
- **Test unitarios y e2e junto al c√≥digo**, integrados al pipeline de CI/CD
- **Storybook para componentes compartidos** con ejemplos light/dark
- **Documentaci√≥n de componentes reutilizables** con variantes y props

### Configuraci√≥n
- **Configuraci√≥n multi-entorno y fuera del c√≥digo** (no hardcode)
- **Variables CSS para temas** personalizables

---

## 4. Antipatrones y Smells Angular 20

| Antipatr√≥n | Descripci√≥n | Alternativa |
|-----------|------------|-----------|
| Usar `*ngIf`, `*ngFor`, `*ngSwitch` | Directivas deprecadas en v20, remover√°n en v22 | Usar `@if`, `@for`, `@switch` bloques |
| L√≥gica compleja en plantillas HTML | Dif√≠cil de mantener, no se puede testear | Extraer a TS/computed/pipe |
| Subscribes manuales en componentes | Memory leaks, suscripciones olvidadas | Usar async pipe o signals |
| No usar `any` pero usar demasiado `unknown` | Pierde type safety | Inferir tipos expl√≠citamente |
| Nombres ambiguos y archivos gen√©ricos | `utils.ts`, `common.ts`, `service.ts` | Nombres con contexto de dominio |
| M√°s de un concepto principal por archivo | Dif√≠cil de reutilizar y testear | Un concepto = un archivo |
| Guardar tokens/datos sensibles en localStorage | Seguridad d√©bil | session/cookies seguras, HTTPS only |
| Cambio de detecci√≥n sin OnPush | Performance degradada | Usar OnPush + signals |
| @for sin trackBy (old) o track (new) | Memory leaks, DOM ineficiente | Siempre incluir `track` en @for |
| Componentes acoplados a estado global | Dif√≠cil de testear y reutilizar | Inyectar servicios, signals locales |
| No migrar de `*ngIf` a `@if` cuando sea posible | Deprecated warnings, mejor evitarlas | Usar control flow blocks |
| Template y estilos inline en `.ts` | Dificulta mantenimiento y violates separation of concerns | Siempre archivos `.html` y `.scss` separados |
| CSS custom sin justificaci√≥n | Inconsistencia de estilos, dif√≠cil de mantener | Usar Tailwind CSS v4 utility classes |
| No implementar dark mode | Mala UX, no cumple con est√°ndares modernos | Siempre usar `dark:` classes de Tailwind |
| Duplicar componentes similares | C√≥digo repetido, dif√≠cil de mantener | Componentizar y parametrizar con @Input |
| Hardcodear colores sin variables | Imposible cambiar tema, no soporta dark mode | Usar variables CSS o clases de Tailwind |
| Componentes gigantes (>300 l√≠neas) | Dif√≠cil de mantener y testear | Dividir en componentes m√°s peque√±os |

---

## 5. Buenas Pr√°cticas TypeScript 5.9.2

### Configuraci√≥n Reforzada
```json
{
  "compilerOptions": {
    "target": "es2022",
    "module": "ESNext",
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

### Mejores Pr√°cticas TypeScript
- Siempre usar `strict: true` y null checks estrictos
- Inferencia de tipos: dejar que el compilador infiera cuando sea obvio
- Declarar interfaces y tipos expl√≠citos (nunca abusar de `any`)
- Usar enums y discriminated unions para estados/condiciones
- Preferir la composici√≥n sobre herencia
- Usar las utilidades modernas (`satisfies`, template literal types, conditional types)
- Minimizar el uso de type assertions y explicar su prop√≥sito cuando sean necesarios
- Usar assertions y guards en vez de coerciones directas
- Evitar interfaces gigantes, mejor fragmentar con tipos m√°s peque√±os y claros
- Documentar usando `/** ... */` encima de funciones, m√©todos y clases relevantes
- Usar tipos readonly para prevenir mutaciones accidentales
- Aplicar type narrowing con type guards en condicionales

---

## 6. Antipatrones TypeScript 5.9.2

| Antipatr√≥n | Problema | Soluci√≥n |
|-----------|---------|---------|
| Uso de `any` como "comod√≠n" | Pierde type safety completamente | Usar `unknown` si es necesario, luego type guard |
| Ignorar `strictNullChecks` | Errores sutiles de ejecuci√≥n | Activar strict, usar optional chaining |
| Abusar de type assertions (`as Type`) | Puede ocultar errores reales | Type guards, type narrowing en lugar de assertions |
| No declarar tipo de variables | Tipo impl√≠cito puede causar confusiones | Siempre tipado expl√≠cito en variables p√∫blicas |
| Ignorar errores con `// @ts-ignore` | Acumula deuda t√©cnica | Resolver el error real o documentar bien |
| Interfaces/Tipos con demasiadas propiedades | Viola Single Responsibility | Fragmentar en tipos m√°s peque√±os |
| No usar `readonly` en objetos | Permite mutabilidades accidentales | Usar readonly, Readonly<T> utility |
| Faltas de documentar shape de objetos | Dif√≠cil de entender retornos | JSDoc comentarios (`/** ... */`) |
| Gen√©ricos excesivamente complejos | C√≥digo dif√≠cil de seguir | Simplificar, usar tipos concretos si es posible |
| Type assertions en datos externos | Falsa seguridad de tipo | Validaci√≥n en runtime + tipo checking |

---

## 7. Checklist Autom√°tica (Angular 20 + TypeScript 5.9.2)

### Pre-Codificaci√≥n (OBLIGATORIO)
- [ ] **Consultar MCP Server de Angular** (`mcp_angular-cli_get_best_practices`)
- [ ] **Buscar API/concepto espec√≠fico** en MCP si es necesario (`mcp_angular-cli_search_documentation`)
- [ ] Revisar `DocSportPlanner/` para contexto de negocio y dominio
- [ ] Verificar `back/typescript-best-practices.md` para convenciones TypeScript
- [ ] Revisar componentes existentes en `shared/components/` antes de crear nuevos

### Arquitectura y Estructura
- [ ] **OBLIGATORIO:** Cada componente con `.ts`, `.html`, `.scss` **separados** (NO inline)
- [ ] Estructura por dominio/feature, nunca solo por tipo t√©cnico
- [ ] Componentes standalone por defecto (`standalone: true`)
- [ ] Componentizar elementos reutilizables en `shared/components/`
- [ ] Componentes peque√±os y enfocados (idealmente <300 l√≠neas)
- [ ] Nombres expl√≠citos; evitar gen√©ricos o camel ambiguo
- [ ] Test junto al c√≥digo, con cobertura m√≠nima

### Control Flow y Sintaxis Angular 20
- [ ] Ning√∫n uso de `*ngIf`, `*ngFor`, `*ngSwitch` ‚Üí Usar `@if`, `@for`, `@switch`
- [ ] Bloques de control flow tienen `track` en `@for` (obligatorio)
- [ ] Async pipe en lugar de subscribes manuales
- [ ] No l√≥gica de negocio en plantillas HTML

### Signals y Estado
- [ ] Signals preferido para estado local, RxJS solo para casos globales o complejos
- [ ] `ChangeDetectionStrategy.OnPush` en todos los componentes
- [ ] No hay memoria leaks en componentes destruidos

### TypeScript 5.9.2
- [ ] Tipado estricto activado (`strict: true` en tsconfig) y sin `any`
- [ ] Configuraci√≥n modernizada de TS (`strict`, `noUnusedLocals`, etc.) y linting avanzado
- [ ] Type narrowing en @switch para discriminated unions
- [ ] Consultar `back/typescript-best-practices.md` para patrones espec√≠ficos

### Performance y Optimizaci√≥n
- [ ] `ChangeDetectionStrategy.OnPush` en todos los componentes
- [ ] Lazy loading de rutas y features para agilizar arranque inicial
- [ ] Track functions optimizadas en `@for`

### Estilos y UI (Tailwind CSS v4)
- [ ] **OBLIGATORIO:** Usar Tailwind CSS v4 para TODOS los estilos
- [ ] **OBLIGATORIO:** Implementar modo `light` Y `dark` con clases `dark:`
- [ ] Probar componente en AMBOS modos (light/dark) antes de commit
- [ ] NO escribir CSS custom en `.scss` sin justificaci√≥n fuerte
- [ ] Usar utility classes de Tailwind en lugar de CSS custom
- [ ] Variables CSS para colores de tema si es necesario
- [ ] Responsive design con breakpoints de Tailwind

### Componentizaci√≥n
- [ ] Reutilizar componentes de `shared/components/` cuando sea posible
- [ ] Crear componente compartido si se usa en 2+ lugares
- [ ] Documentar componentes reutilizables con ejemplos
- [ ] Props bien tipados con `@Input()` y valores por defecto
- [ ] Componentes at√≥micos (button, input, card, badge) disponibles

### Seguridad y Configuraci√≥n
- [ ] Configuraci√≥n sensible externa (environments, config loaders)
- [ ] No hardcodear URLs, tokens o credenciales
- [ ] Storybook/documentaci√≥n visible en el repo
- [ ] Documentaci√≥n de componentes compartidos actualizada

### Validaci√≥n Final
- [ ] **Re-verificar con MCP Server** si hay dudas sobre implementaci√≥n
- [ ] Build exitoso sin warnings (`ng build`)
- [ ] Tests pasando (`ng test`)
- [ ] Linting sin errores (`ng lint`)

---

## 8. Ejemplo Completo: Componente Moderno Angular 20

### Estructura de Carpeta
```
src/features/users/
‚îú‚îÄ‚îÄ list/
‚îÇ   ‚îú‚îÄ‚îÄ user-list.component.ts
‚îÇ   ‚îú‚îÄ‚îÄ user-list.component.html
‚îÇ   ‚îú‚îÄ‚îÄ user-list.component.scss
‚îÇ   ‚îî‚îÄ‚îÄ user-list.component.spec.ts
‚îú‚îÄ‚îÄ detail/
‚îÇ   ‚îú‚îÄ‚îÄ user-detail.component.ts
‚îÇ   ‚îú‚îÄ‚îÄ user-detail.component.html
‚îÇ   ‚îú‚îÄ‚îÄ user-detail.component.scss
‚îÇ   ‚îî‚îÄ‚îÄ user-detail.component.spec.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ user.service.ts
‚îî‚îÄ‚îÄ models/
    ‚îî‚îÄ‚îÄ user.model.ts
```

### user-list.component.ts
```typescript
import { Component, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { signal } from '@angular/core';
import { UserService } from '../services/user.service';
import { User } from '../models/user.model';

@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './user-list.component.html',
  styleUrls: ['./user-list.component.scss'],
  changeDetection: 'OnPush'
})
export class UserListComponent implements OnInit {
  private userService = inject(UserService);
  users = signal<User[]>([]);
  isLoading = signal(false);
  error = signal<string | null>(null);

  ngOnInit() {
    this.loadUsers();
  }

  private loadUsers() {
    this.isLoading.set(true);
    this.userService.getUsers().subscribe({
      next: (data) => {
        this.users.set(data);
        this.isLoading.set(false);
      },
      error: (err) => {
        this.error.set('Failed to load users');
        this.isLoading.set(false);
      }
    });
  }
}
```

### user-list.component.html
```html
@if (isLoading()) {
  <p class="loading">Loading users...</p>
}

@if (error()) {
  <div class="error">{{ error() }}</div>
}

@if (!isLoading() && users().length > 0) {
  <ul class="user-list">
    @for (user of users(); track user.id) {
      <li class="user-item">
        <a [routerLink]="['/users', user.id]">
          {{ user.name }} ({{ user.email }})
        </a>
      </li>
    }
  </ul>
}

@if (!isLoading() && users().length === 0 && !error()) {
  <p>No users found</p>
}
```

### user-list.component.scss
```scss
.loading {
  color: #666;
  font-style: italic;
}

.error {
  color: red;
  padding: 10px;
  background-color: #ffe6e6;
  border-radius: 4px;
}

.user-list {
  list-style: none;
  padding: 0;
}

.user-item {
  padding: 10px;
  border-bottom: 1px solid #eee;

  a {
    text-decoration: none;
    color: #0066cc;

    &:hover {
      text-decoration: underline;
    }
  }
}
```

### user.model.ts
```typescript
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'editor' | 'viewer';
}
```

### user.service.ts
```typescript
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { User } from '../models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private http = inject(HttpClient);
  private apiUrl = '/api/users';

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }

  getUser(id: string): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${id}`);
  }
}
```

---

## 9. Fuentes Relevantes y Referencias Oficiales

### üî¥ Recurso Principal (OBLIGATORIO)
- **MCP Server de Angular** - Acceso directo a best practices y documentaci√≥n oficial actualizada
  - Tool: `mcp_angular-cli_get_best_practices` - Best Practices Guide completa
  - Tool: `mcp_angular-cli_search_documentation` - B√∫squeda en angular.dev

### üìö Documentaci√≥n Oficial Angular
- Angular 20 Control Flow Documentation (angular.dev) - **Consultar v√≠a MCP Server**
- Angular Style Guide y Architectural Guidelines - **Consultar v√≠a MCP Server**
- Angular Deprecation Notice: ngIf/ngFor/ngSwitch - **Consultar v√≠a MCP Server**
- Angular Control Flow Migration Schematic - **Consultar v√≠a MCP Server**

### üîß TypeScript
- TypeScript 5.9.x Release Notes y Best Practices
- `back/typescript-best-practices.md` - Convenciones espec√≠ficas del proyecto

### üíº Documentaci√≥n del Proyecto
- `DocSportPlanner/` - Contexto de negocio, reglas de dominio, requisitos
- `DocSportPlanner/docs/tecnico/` - Stack tecnol√≥gico y modelo de datos
- `DocSportPlanner/docs/negocio/` - Casos de uso y terminolog√≠a del dominio

### ‚ö†Ô∏è Nota Importante
**Siempre prioriza la informaci√≥n del MCP Server** sobre cualquier otra fuente, ya que provee acceso directo a la documentaci√≥n oficial m√°s actualizada de Angular. Este archivo (AGENTS.md) se mantiene alineado con las best practices oficiales, pero en caso de duda o contradicci√≥n, **el MCP Server tiene la autoridad final**.

---

## 10. Pr√≥ximos Pasos para Agentes Autom√°ticos

### Workflow de Desarrollo Obligatorio

1. **üîç CONSULTAR MCP SERVER PRIMERO**
   - Ejecutar `mcp_angular-cli_get_best_practices` antes de cualquier tarea
   - Usar `mcp_angular-cli_search_documentation` para APIs/conceptos espec√≠ficos
   - **La informaci√≥n del MCP tiene prioridad absoluta**

2. **üìã Validar cada pull request/generaci√≥n** contra la checklist de este documento

3. **üîß Aplicar linting avanzado** para naming, tipado estricto, modularidad

4. **üîÑ Ejecutar schematic de migraci√≥n** `ng update @angular/core --name=control-flow-migration` en proyectos legacy

5. **üí° Sugerir refactor autom√°tico** ante l√≥gicas complejas en templates o componentes

6. **üèóÔ∏è Analizar dependencias** para asegurar l√≠mites de dominio claros

7. **üß™ Integrar pruebas y documentaci√≥n UI** en el pipeline

### Orden de Prioridad de Fuentes de Informaci√≥n

1. **ü•á MCP Server de Angular** (`mcp_angular-cli_*` tools) - **M√ÅXIMA PRIORIDAD**
2. **ü•à Documentaci√≥n oficial de Angular** (https://angular.dev)
3. **ü•â Este archivo (front/AGENTS.md)** - Convenciones espec√≠ficas del proyecto
4. **üìö TypeScript best practices** (`back/typescript-best-practices.md`)
5. **üíº Documentaci√≥n de negocio** (`DocSportPlanner/`)

### Ejemplos de Consultas al MCP Server

**Antes de crear un componente nuevo:**
```
1. mcp_angular-cli_get_best_practices
   ‚Üí Leer secci√≥n de componentes standalone

2. mcp_angular-cli_search_documentation
   Query: "standalone components"
   ‚Üí Obtener ejemplos actualizados
```

**Antes de implementar signals:**
```
1. mcp_angular-cli_search_documentation
   Query: "signals computed effect"
   ‚Üí Ver API completa y ejemplos

2. mcp_angular-cli_search_documentation
   Query: "signals vs observables"
   ‚Üí Entender cu√°ndo usar cada uno
```

**Antes de usar control flow:**
```
1. mcp_angular-cli_search_documentation
   Query: "@if @for @switch control flow"
   ‚Üí Sintaxis y mejores pr√°cticas actualizadas
```

### üö® Recordatorio Cr√≠tico

> **Siempre que vayas a escribir c√≥digo Angular:**
> 
> 1. Abre con `mcp_angular-cli_get_best_practices`
> 2. Busca conceptos espec√≠ficos con `mcp_angular-cli_search_documentation`
> 3. Solo entonces implementa siguiendo las best practices obtenidas
> 
> **No conf√≠es solo en conocimiento est√°tico o cached. El MCP Server tiene la informaci√≥n oficial m√°s actualizada.**

---

### S√≠ntesis Directiva
El enfoque m√°s moderno y robusto para Angular 20 exige: **consultar siempre el MCP Server de Angular primero**, bloques de control flow (@if/@for/@switch), standalone, signals, folder structure por dominio, tipado estricto de TypeScript, y una fuerte automatizaci√≥n en revisi√≥n de antipatterns. **Cr√≠tico**: No usar las directivas deprecadas `*ngIf`, `*ngFor`, `*ngSwitch`; migrar a los nuevos bloques de control inmediatamente para evitar warnings y asegurar compatibilidad con v22. **La informaci√≥n del MCP Server tiene prioridad absoluta sobre cualquier otra fuente.**

