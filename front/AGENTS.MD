# Gu√≠a Integral de Arquitectura, Patrones, Antipatrones y Buenas Pr√°cticas Angular 20 + TypeScript 5.9.2

## Resumen Ejecutivo
Esta gu√≠a est√° orientada a agentes autom√°ticos y desarrolladores avanzados, cubriendo:
- Arquitectura limpia y escalable en Angular 20
- Patrones y antipatrones en Angular y TypeScript 5.9.2
- Control flow modernizado con bloques @if, @for, @switch (reemplazando directivas deprecadas)
- Mejores pr√°cticas para estructuraci√≥n de componentes en archivos separados
- Checklist para revisi√≥n autom√°tica y codificaci√≥n asistida

---

> üìÅ **Nota - Documentaci√≥n del proyecto**
>
> El repositorio incluye una carpeta central con las especificaciones del proyecto, modelos y decisiones de dise√±o: `C:\Proyectos\SportPlanner\DocSportPlanner`.
>
> - Revisa `DocSportPlanner/` (por ejemplo `DocSportPlanner/docs/`, `DocSportPlanner/docs/tecnico/`, `DocSportPlanner/docs/tecnico/openapi.yaml`) antes de iniciar tareas de dise√±o o de backend/frontend.
> - Las `instructions` y `agents` para `front` y `back` deben consultar estos documentos para alinear requisitos, contratos de API y convenciones.


## 1. CR√çTICO: Control Flow Blocks - Cambio Fundamental en Angular 20

### Directivas Deprecadas en Angular 20
A partir de **Angular 20**, las siguientes directivas estructurales est√°n **DEPRECADAS** e ir√°n a remover en **v22**:
- `*ngIf` ‚Üí Usar `@if` block
- `*ngFor` ‚Üí Usar `@for` block
- `[ngSwitch]`, `*ngSwitchCase`, `*ngSwitchDefault` ‚Üí Usar `@switch` block

**Acci√≥n recomendada**: Ejecutar autom√°ticamente el schematic de migraci√≥n:
```bash
ng update @angular/core --name=control-flow-migration
```

### Nueva Sintaxis: Bloques de Control de Flujo

#### @if / @else if / @else
```typescript
// ‚úÖ CORRECTO - Angular 20
@if (condition) {
  <p>Condition is true</p>
} @else if (otherCondition) {
  <p>Other condition is true</p>
} @else {
  <p>No conditions met</p>
}

// ‚ùå DEPRECATED - Evitar
<div *ngIf="condition">
  <p>Condition is true</p>
</div>
<div *ngIf="otherCondition">
  <p>Other condition is true</p>
</div>
<div *ngIf="!condition && !otherCondition">
  <p>No conditions met</p>
</div>
```

#### @for (reemplaza *ngFor)
```typescript
// ‚úÖ CORRECTO - Angular 20
@for (item of items; track item.id) {
  <div>{{ item.name }}</div>
}

// Con @empty para lista vac√≠a
@for (item of items; track item.id) {
  <li>{{ item.name }}</li>
} @empty {
  <li>No items available</li>
}

// Variables locales: $index, $count, $first, $last, $even, $odd
@for (item of items; track item.id; let idx = $index, isEven = $even) {
  <div [class.even]="isEven">{{ idx }}: {{ item.name }}</div>
}

// ‚ùå DEPRECATED - Evitar
<div *ngFor="let item of items; trackBy: trackByFn">
  {{ item.name }}
</div>
```

**Ventaja clave**: El `track` es **obligatorio** en `@for` (evita memory leaks), mejora performance 90% respecto a `*ngFor`.

#### @switch / @case / @default
```typescript
// ‚úÖ CORRECTO - Angular 20
@switch (userRole) {
  @case ('admin') {
    <app-admin-dashboard />
  }
  @case ('editor') {
    <app-editor-dashboard />
  }
  @default {
    <app-viewer-dashboard />
  }
}

// ‚ùå DEPRECATED - Evitar
<div [ngSwitch]="userRole">
  <div *ngSwitchCase="'admin'">
    <app-admin-dashboard />
  </div>
  <div *ngSwitchCase="'editor'">
    <app-editor-dashboard />
  </div>
  <div *ngSwitchDefault>
    <app-viewer-dashboard />
  </div>
</div>
```

**Nota importante**: No hay "fall-through" en `@switch`, no necesita `break`.

### Migraci√≥n y Consideraciones
- **Control flow schematics**: Migra autom√°ticamente `*ngIf`, `*ngFor`, `*ngSwitch`
- **NgIf con async pipe**: La nueva sintaxis tambi√©n aplica bien con async:
  ```typescript
  @if (country$ | async; as countryList) {
    <span>Found {{ countryList.length }} countries</span>
  }
  ```
- **No requiere imports**: Los bloques `@if`, `@for`, `@switch` est√°n "built-in" en Angular 20+
- **Mejor legibilidad y type checking**: Los bloques soportan type narrowing en switch

---

## 2. Arquitectura Moderna Angular 20

### Separaci√≥n de Archivos (OBLIGATORIO)
- Cada componente siempre debe tener su `.ts`, `.html` y `.css/.scss` en archivos separados y nombrados igual, agrupados en el mismo directorio.
- No juntar plantilla HTML ni estilos en el archivo `.ts` del componente salvo excepciones para demos/prototipos peque√±os.
- Estructura ejemplo para `user-profile`:
  ```
  src/features/user/profile/
  ‚îú‚îÄ‚îÄ user-profile.component.ts
  ‚îú‚îÄ‚îÄ user-profile.component.html
  ‚îú‚îÄ‚îÄ user-profile.component.scss
  ‚îú‚îÄ‚îÄ user-profile.component.spec.ts
  ```

### Organizaci√≥n de Carpetas
- Organizar por dominio/feature, no por tipo t√©cnico (evitar `components/`, `services/` gen√©ricos)
- Aplicar Domain-Driven Design (DDD) donde sea relevante.
- Colocar archivos de test (`*.spec.ts`) junto al c√≥digo bajo prueba.
- Usar lazy loading y feature modules por dominio.

### Standalone Components
- Preferir componentes `standalone: true` usando la API moderna.
- Minimizar NgModules y evitar m√≥dulos redundantes.
- Eliminar CommonModule imports innecesarias en componentes standalone (bloques @if/@for no requieren imports).

### Naming y Conceptos
- Prefiere nombres cortos, claros, √∫nicos y con significado de dominio.
- Usar un concepto por archivo/feature.
- Evitar nombres gen√©ricos: `utils.ts`, `common.ts`, `constants.ts` sin contexto.

---

## 3. Patrones Recomendados Angular 20

- **Uso de signals** para estado local y derived state (preferir `signal()` sobre `BehaviorSubject` para UI local).
- **ChangeDetectionStrategy.OnPush** por defecto en todos los componentes.
- **Servicios con una √∫nica responsabilidad**, singleton v√≠a `providedIn: 'root'`.
- **Lazy loading de rutas y features** para agilizar arranque inicial.
- **Test unitarios y e2e junto al c√≥digo**, integrados al pipeline de CI/CD.
- **Storybook o documentaci√≥n UI** acoplada al feature.
- **Configuraci√≥n multi-entorno y fuera del c√≥digo** (no hardcode).
- **Bloques de control flow (@if, @for, @switch)** en lugar de directivas deprecadas.
- **Async pipe** en lugar de subscribes manuales en templates.
- **Type narrowing** en @switch para aprovechamiento de tipos discriminated unions.

---

## 4. Antipatrones y Smells Angular 20

| Antipatr√≥n | Descripci√≥n | Alternativa |
|-----------|------------|-----------|
| Usar `*ngIf`, `*ngFor`, `*ngSwitch` | Directivas deprecadas en v20, remover√°n en v22 | Usar `@if`, `@for`, `@switch` bloques |
| L√≥gica compleja en plantillas HTML | Dif√≠cil de mantener, no se puede testear | Extraer a TS/computed/pipe |
| Subscribes manuales en componentes | Memory leaks, suscripciones olvidadas | Usar async pipe o signals |
| No usar `any` pero usar demasiado `unknown` | Pierde type safety | Inferir tipos expl√≠citamente |
| Nombres ambiguos y archivos gen√©ricos | `utils.ts`, `common.ts`, `service.ts` | Nombres con contexto de dominio |
| M√°s de un concepto principal por archivo | Dif√≠cil de reutilizar y testear | Un concepto = un archivo |
| Guardar tokens/datos sensibles en localStorage | Seguridad d√©bil | session/cookies seguras, HTTPS only |
| Cambio de detecci√≥n sin OnPush | Performance degradada | Usar OnPush + signals |
| @for sin trackBy (old) o track (new) | Memory leaks, DOM ineficiente | Siempre incluir `track` en @for |
| Componentes acoplados a estado global | Dif√≠cil de testear y reutilizar | Inyectar servicios, signals locales |
| No migrar de `*ngIf` a `@if` cuando sea posible | Deprecated warnings, mejor evitarlas | Usar control flow blocks |

---

## 5. Buenas Pr√°cticas TypeScript 5.9.2

### Configuraci√≥n Reforzada
```json
{
  "compilerOptions": {
    "target": "es2022",
    "module": "ESNext",
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

### Mejores Pr√°cticas TypeScript
- Siempre usar `strict: true` y null checks estrictos
- Inferencia de tipos: dejar que el compilador infiera cuando sea obvio
- Declarar interfaces y tipos expl√≠citos (nunca abusar de `any`)
- Usar enums y discriminated unions para estados/condiciones
- Preferir la composici√≥n sobre herencia
- Usar las utilidades modernas (`satisfies`, template literal types, conditional types)
- Minimizar el uso de type assertions y explicar su prop√≥sito cuando sean necesarios
- Usar assertions y guards en vez de coerciones directas
- Evitar interfaces gigantes, mejor fragmentar con tipos m√°s peque√±os y claros
- Documentar usando `/** ... */` encima de funciones, m√©todos y clases relevantes
- Usar tipos readonly para prevenir mutaciones accidentales
- Aplicar type narrowing con type guards en condicionales

---

## 6. Antipatrones TypeScript 5.9.2

| Antipatr√≥n | Problema | Soluci√≥n |
|-----------|---------|---------|
| Uso de `any` como "comod√≠n" | Pierde type safety completamente | Usar `unknown` si es necesario, luego type guard |
| Ignorar `strictNullChecks` | Errores sutiles de ejecuci√≥n | Activar strict, usar optional chaining |
| Abusar de type assertions (`as Type`) | Puede ocultar errores reales | Type guards, type narrowing en lugar de assertions |
| No declarar tipo de variables | Tipo impl√≠cito puede causar confusiones | Siempre tipado expl√≠cito en variables p√∫blicas |
| Ignorar errores con `// @ts-ignore` | Acumula deuda t√©cnica | Resolver el error real o documentar bien |
| Interfaces/Tipos con demasiadas propiedades | Viola Single Responsibility | Fragmentar en tipos m√°s peque√±os |
| No usar `readonly` en objetos | Permite mutabilidades accidentales | Usar readonly, Readonly<T> utility |
| Faltas de documentar shape de objetos | Dif√≠cil de entender retornos | JSDoc comentarios (`/** ... */`) |
| Gen√©ricos excesivamente complejos | C√≥digo dif√≠cil de seguir | Simplificar, usar tipos concretos si es posible |
| Type assertions en datos externos | Falsa seguridad de tipo | Validaci√≥n en runtime + tipo checking |

---

## 7. Checklist Autom√°tica (Angular 20 + TypeScript 5.9.2)

- [ ] Cada componente: `.ts`, `.html`, `.scss`/`.css` separadas, mismo nombre
- [ ] Ning√∫n uso de `*ngIf`, `*ngFor`, `*ngSwitch` ‚Üí Usar `@if`, `@for`, `@switch`
- [ ] Bloques de control flow tienen `track` en `@for` (obligatorio)
- [ ] Estructura por dominio/feature, nunca solo por tipo t√©cnico
- [ ] Signals preferido para estado local, RxJS solo para casos globales o complejos
- [ ] Componentes standalone por defecto (`standalone: true`)
- [ ] `ChangeDetectionStrategy.OnPush` en todos los componentes
- [ ] Nombres expl√≠citos; evitar gen√©ricos o camel ambiguo
- [ ] Tipado estricto activado (`strict: true` en tsconfig) y sin `any`
- [ ] No l√≥gica de negocio en plantillas HTML
- [ ] Test junto al c√≥digo, con cobertura m√≠nima
- [ ] Configuraci√≥n sensible externa (environments, config loaders)
- [ ] Storybook/documentaci√≥n visible en el repo
- [ ] Configuraci√≥n modernizada de TS (`strict`, `noUnusedLocals`, etc.) y linting avanzado
- [ ] Async pipe en lugar de subscribes manuales
- [ ] No hay memoria leaks en componentes destruidos
- [ ] Type narrowing en @switch para discriminated unions

---

## 8. Ejemplo Completo: Componente Moderno Angular 20

### Estructura de Carpeta
```
src/features/users/
‚îú‚îÄ‚îÄ list/
‚îÇ   ‚îú‚îÄ‚îÄ user-list.component.ts
‚îÇ   ‚îú‚îÄ‚îÄ user-list.component.html
‚îÇ   ‚îú‚îÄ‚îÄ user-list.component.scss
‚îÇ   ‚îî‚îÄ‚îÄ user-list.component.spec.ts
‚îú‚îÄ‚îÄ detail/
‚îÇ   ‚îú‚îÄ‚îÄ user-detail.component.ts
‚îÇ   ‚îú‚îÄ‚îÄ user-detail.component.html
‚îÇ   ‚îú‚îÄ‚îÄ user-detail.component.scss
‚îÇ   ‚îî‚îÄ‚îÄ user-detail.component.spec.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ user.service.ts
‚îî‚îÄ‚îÄ models/
    ‚îî‚îÄ‚îÄ user.model.ts
```

### user-list.component.ts
```typescript
import { Component, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { signal } from '@angular/core';
import { UserService } from '../services/user.service';
import { User } from '../models/user.model';

@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './user-list.component.html',
  styleUrls: ['./user-list.component.scss'],
  changeDetection: 'OnPush'
})
export class UserListComponent implements OnInit {
  private userService = inject(UserService);
  users = signal<User[]>([]);
  isLoading = signal(false);
  error = signal<string | null>(null);

  ngOnInit() {
    this.loadUsers();
  }

  private loadUsers() {
    this.isLoading.set(true);
    this.userService.getUsers().subscribe({
      next: (data) => {
        this.users.set(data);
        this.isLoading.set(false);
      },
      error: (err) => {
        this.error.set('Failed to load users');
        this.isLoading.set(false);
      }
    });
  }
}
```

### user-list.component.html
```html
@if (isLoading()) {
  <p class="loading">Loading users...</p>
}

@if (error()) {
  <div class="error">{{ error() }}</div>
}

@if (!isLoading() && users().length > 0) {
  <ul class="user-list">
    @for (user of users(); track user.id) {
      <li class="user-item">
        <a [routerLink]="['/users', user.id]">
          {{ user.name }} ({{ user.email }})
        </a>
      </li>
    }
  </ul>
}

@if (!isLoading() && users().length === 0 && !error()) {
  <p>No users found</p>
}
```

### user-list.component.scss
```scss
.loading {
  color: #666;
  font-style: italic;
}

.error {
  color: red;
  padding: 10px;
  background-color: #ffe6e6;
  border-radius: 4px;
}

.user-list {
  list-style: none;
  padding: 0;
}

.user-item {
  padding: 10px;
  border-bottom: 1px solid #eee;

  a {
    text-decoration: none;
    color: #0066cc;

    &:hover {
      text-decoration: underline;
    }
  }
}
```

### user.model.ts
```typescript
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'editor' | 'viewer';
}
```

### user.service.ts
```typescript
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { User } from '../models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private http = inject(HttpClient);
  private apiUrl = '/api/users';

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }

  getUser(id: string): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${id}`);
  }
}
```

---

## 9. Fuentes Relevantes y Referencias Oficiales
- Angular 20 Control Flow Documentation (angular.dev)
- Angular Style Guide y Architectural Guidelines
- TypeScript 5.9.x Release Notes y Best Practices
- Angular Deprecation Notice: ngIf/ngFor/ngSwitch
- Angular Control Flow Migration Schematic

---

## 10. Pr√≥ximos Pasos para Agentes Autom√°ticos

1. **Validar cada pull request/generaci√≥n** contra la lista de checklist.
2. **Aplicar linting avanzado** para naming, tipado estricto, modularidad.
3. **Ejecutar schematic de migraci√≥n** `ng update @angular/core --name=control-flow-migration` en proyectos legacy.
4. **Sugerir refactor autom√°tico** ante l√≥gicas complejas en templates o componentes.
5. **Analizar dependencias** para asegurar l√≠mites de dominio claros.
6. **Integrar pruebas y documentaci√≥n UI** en el pipeline.

---

### S√≠ntesis Directiva
El enfoque m√°s moderno y robusto para Angular 20 exige: bloques de control flow (@if/@for/@switch), standalone, signals, folder structure por dominio, tipado estricto de TypeScript, y una fuerte automatizaci√≥n en revisi√≥n de antipatterns. **Cr√≠tico**: No usar las directivas deprecadas `*ngIf`, `*ngFor`, `*ngSwitch`; migrar a los nuevos bloques de control inmediatamente para evitar warnings y asegurar compatibilidad con v22.

